"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4867],{7248:function(e,n,a){a.r(n),a(3696);var t=a(1445);function s(){return s=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)({}).hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e},s.apply(null,arguments)}function o(e){let{components:n,...a}=e;return(0,t.yg)("wrapper",s({components:n},a),(0,t.yg)("p",null,"Any time one file depends on another, webpack treats this as a ",(0,t.yg)("em",{parentName:"p"},"dependency"),". This allows webpack to take non-code assets, such as images or web fonts, and also provide them as ",(0,t.yg)("em",{parentName:"p"},"dependencies")," for your application."),(0,t.yg)("p",null,"When webpack processes your application, it starts from a list of modules defined on the command line or in its configuration file.\nStarting from these ",(0,t.yg)("a",{href:"/concepts/entry-points/",parentName:"p"},(0,t.yg)("em",{parentName:"a"},"entry points")),", webpack recursively builds a ",(0,t.yg)("em",{parentName:"p"},"dependency graph")," that includes every module your application needs, then bundles all of those modules into a small number of ",(0,t.yg)("em",{parentName:"p"},"bundles")," - often, only one - to be loaded by the browser."),(0,t.yg)("aside",{className:"tip"},(0,t.yg)("h6",{className:"tip__prefix",parentName:"aside"},"tip"),(0,t.yg)("p",{parentName:"aside"},"Bundling your application is especially powerful for ",(0,t.yg)("em",{parentName:"p"},"HTTP/1.1")," clients, as it minimizes the number of times your app has to wait while the browser starts a new request. For ",(0,t.yg)("em",{parentName:"p"},"HTTP/2"),", you can also use ",(0,t.yg)("a",{href:"/guides/code-splitting/",parentName:"p"},"Code Splitting")," to achieve best results.")))}o.isMDXComponent=!0,n.default=o}}]);